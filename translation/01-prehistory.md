
## LISP 历史之前, 1956 年夏到 58 年夏

我对于 IBM 704 电脑上处理人工智能工作代数的代数的表处理的渴望,
开始于 1956 年, 在 Dartmouth 的夏季的人工智能研究项目期间,
那是第一次有组织的关于 AI 的研究
这次会议中, Newell, Shaw 还有 Simon 介绍了 IPL 2,
一门 Rand Corporation 的 JOHNNIAC 计算机上的表处理语言,
其中他们部署了他们的逻辑理论程序
没什么要山寨 IPL 的诱惑, 因为其形式基于的 JOHNNIAC 装载器恰好对他们可用,
并且 FORTRAN 关于用代数形式写程序的想法很吸引人
很快发现, 对一般的函数表达式进行复合, 可以形成任意的子表达式,
这给了人们充分的理由去做一们代数形式的语言

为 IBM 704 开发一门语言有两个目的
第一, IBM 很慷慨地要在 M.I.T 建立一个 Dartmouth 是能够使用的,
New England Computation Center
第二, IBM 承诺会开发证明平面集合定理(基于 Marvin Minsky 的猜想)的程序,
并且我作为项目的顾问
当时 IBM 看起来像是投了追求人工智能研究的很大一个赌注,
于是更深入的项目值得期待
当时还不清楚会不会 IBM 的 FORTRAN 项目带来一门语言,
这门语言里表处理能被方便地实现出来, 会不会需要新的语言
但是, 好多关于什么会出现的想法都是不相干的

除了几何程序的咨询, 我自己人工智能的研究沿着规划进行,
最后在 1958 年完成了 Advice Taker 提案 (McCarthy 1959)
其中涉及了用一门形式语言的语句来表示世界的信息,
以及一个能做逻辑推理决定做什么的推理程序
看起来用表结构表示语句很合适, 现在依然是,
而且一门表处理语言同样看起来适合对涉及推论的操作进行编程, 现在也是

这种符号化信息的内部表示放弃了一贯的中缀记号,
而选择了一种对于编程实质性计算, 比如逻辑推论或者代数简化,
分化或者集成.. 这类任务进行简化的记号
如果外部要用一贯的记号, 就需要写转换程序
绝大多数 LISP 程序对代数表达式用了中缀记法,
因为代码在后边需要做什么之前, 需要确定主要的连接词
在这点上 LISP 与集合所有其他符号计算系统区别开了
COMIT, FORMAC 和 Formula Algol 程序,
都和惯用的符号表达式相似地将计算表示为操作
SNOBOL 操作字符串, 但在字符串怎样用来表示符号化信息上保持中立
这个特性也许能解释 LISP 相对其他语言的成功, 特别是要写大型程序的时候
其优势就像二进制计算机之于十进制, 但优势更大

(1950s 后期, 整洁输出方便输入的记法没有被认为多重要
现在处理输入输出的程序的习惯不合适当时可用的内存
而且, 足够字符集的键盘打孔机和打印器当时不存在)

第一个问题是怎样在 IBM 704 上做表结构
这台电脑有 36 bit 的字, 还有两个 15 bit 的部分, 叫做地址和减量(decrement),
可以通过从 15 bit 的索引寄存器移入移出内容的特殊说明来区分
机器的地址是 15 bits 的, 因此明显表结构要用 15 bits 的指针
那么, 自然想到字被分成 4 部分, 地址, 减量, 前缀, 还有标签部分
后两者每个 3 bits 被减量分隔, 那么不容易被结合成 6 bits 单独一个部分

到这里还有些犹豫基本的操作符应该是什么样子,
因为通过蒙版展开字的一部分得操作被分开考虑了,
相对于从内存通过地址从字取出内容作为函数,
因为值取决于操作执行的瞬间内存里的内容
但是语法上将其看作是函数, 让他能复合, 好处就很明显

因此, 最初提议的函数的集合包含了 `cwr`, 表示:
"Contents of the Word in Register number",
以及 4 个函数用来拽的字的哥哥部分, 并将他们移动到标准位置的右侧
还提议了一个附加函数接收 3 个参数来展开一个容易的 bit 序列(?)

很快又意识到子表达式的展开涉及 `cwr` 展开的地址部分进行复合,
沿着列表还涉及到对 `cwr` 展开的减量部分进行复合
那么, 混合的 `car`, 表示 "Contents and Address part of Register number",
以及类似的 `cdr cpr ctr` 也被定义出来
实现 `car cdr` 的动机也被俗气的现实加强了,
IBM 704 说明(连着索引), 使得这些操作符很容易实现
一个构造操作, 用来从自由存储的表里移除一个字和填进制定内容, 显然也要
出于这个, `cons(a,d,p,t)` 被定义了, 但作为子例程, 而不是函数和值
这些工作在 Dartmouth 完成的, 就不是在计算机上,
因为 New England Computation Center 还没预计在又一年收到 IBM 704

关系到 IBM 的平面几何项目, Nathaniel Rochester 和 Herbert Gelernter,
(在 McCathy 的建议下)决定用在 FORTRAN 里实现一门表处理语言,
因为这看来是最简单能开始的方案, 并且当时为新语言写编译器要很多人/年
这些工作被 IBM 的 Herbert Gelernter 和 Carl Gerberich 开展了,
并且成就了 FLPL, 表示 FORTRAN 表处理语言
Gelernter 和 Gerberich 意识到 `cons` 应该是函数而不是子例程,
而且值应该是从自由存储列表取的字的位置
这让新的表达式能通过`cons` 子子表达式多次复合构造出来
