
## LISP 历史之前, 1956 年夏到 58 年夏

我对于 IBM 704 电脑上处理人工智能工作代数的代数的表处理的渴望,
开始于 1956 年, 在 Dartmouth 的夏季的人工智能研究项目期间,
那是第一次有组织的关于 AI 的研究
这次会议中, Newell, Shaw 还有 Simon 介绍了 IPL 2,
一门 Rand Corporation 的 JOHNNIAC 计算机上的表处理语言,
其中他们部署了他们的逻辑理论程序
没什么要山寨 IPL 的诱惑, 因为其形式基于的 JOHNNIAC 装载器恰好对他们可用,
并且 FORTRAN 关于用代数形式写程序的想法很吸引人
很快发现, 对一般的函数表达式进行复合, 可以形成任意的子表达式,
这给了人们充分的理由去做一们代数形式的语言

为 IBM 704 开发一门语言有两个目的
第一, IBM 很慷慨地要在 M.I.T 建立一个 Dartmouth 是能够使用的,
New England Computation Center
第二, IBM 承诺会开发证明平面集合定理(基于 Marvin Minsky 的猜想)的程序,
并且我作为项目的顾问
当时 IBM 看起来像是投了追求人工智能研究的很大一个赌注,
于是更深入的项目值得期待
当时还不清楚会不会 IBM 的 FORTRAN 项目带来一门语言,
这门语言里表处理能被方便地实现出来, 会不会需要新的语言
但是, 好多关于什么会出现的想法都是不相干的

除了几何程序的咨询, 我自己人工智能的研究沿着规划进行,
最后在 1958 年完成了 Advice Taker 提案 (McCarthy 1959)
其中涉及了用一门形式语言的语句来表示世界的信息,
以及一个能做逻辑推理决定做什么的推理程序
看起来用表结构表示语句很合适, 现在依然是,
而且一门表处理语言同样看起来适合对涉及推论的操作进行编程, 现在也是

这种符号化信息的内部表示放弃了一贯的中缀记号,
而选择了一种对于编程实质性计算, 比如逻辑推论或者代数简化,
分化或者集成.. 这类任务进行简化的记号
如果外部要用一贯的记号, 就需要写转换程序
绝大多数 LISP 程序对代数表达式用了中缀记法,
因为代码在后边需要做什么之前, 需要确定主要的连接词
在这点上 LISP 与集合所有其他符号计算系统区别开了
COMIT, FORMAC 和 Formula Algol 程序,
都和惯用的符号表达式相似地将计算表示为操作
SNOBOL 操作字符串, 但在字符串怎样用来表示符号化信息上保持中立
这个特性也许能解释 LISP 相对其他语言的成功, 特别是要写大型程序的时候
其优势就像二进制计算机之于十进制, 但优势更大

(1950s 后期, 整洁输出方便输入的记法没有被认为多重要
现在处理输入输出的程序的习惯不合适当时可用的内存
而且, 足够字符集的键盘打孔机和打印器当时不存在)

第一个问题是怎样在 IBM 704 上做表结构
这台电脑有 36 bit 的字, 还有两个 15 bit 的部分, 叫做地址和减量(decrement),
可以通过从 15 bit 的索引寄存器移入移出内容的特殊说明来区分
机器的地址是 15 bits 的, 因此明显表结构要用 15 bits 的指针
那么, 自然想到字被分成 4 部分, 地址, 减量, 前缀, 还有标签部分
后两者每个 3 bits 被减量分隔, 那么不容易被结合成 6 bits 单独一个部分

到这里还有些犹豫基本的操作符应该是什么样子,
因为通过蒙版展开字的一部分得操作被分开考虑了,
相对于从内存通过地址从字取出内容作为函数,
因为值取决于操作执行的瞬间内存里的内容
但是语法上将其看作是函数, 让他能复合, 好处就很明显

因此, 最初提议的函数的集合包含了 `cwr`, 表示:
"Contents of the Word in Register number",
以及 4 个函数用来拽的字的哥哥部分, 并将他们移动到标准位置的右侧
还提议了一个附加函数接收 3 个参数来展开一个容易的 bit 序列(?)

很快又意识到子表达式的展开涉及 `cwr` 展开的地址部分进行复合,
沿着列表还涉及到对 `cwr` 展开的减量部分进行复合
那么, 混合的 `car`, 表示 "Contents and Address part of Register number",
以及类似的 `cdr cpr ctr` 也被定义出来
实现 `car cdr` 的动机也被俗气的现实加强了,
IBM 704 说明(连着索引), 使得这些操作符很容易实现
一个构造操作, 用来从自由存储的表里移除一个字和填进制定内容, 显然也要
出于这个, `cons(a,d,p,t)` 被定义了, 但作为子例程, 而不是函数和值
这些工作在 Dartmouth 完成的, 就不是在计算机上,
因为 New England Computation Center 还没预计在又一年收到 IBM 704

关系到 IBM 的平面几何项目, Nathaniel Rochester 和 Herbert Gelernter,
(在 McCathy 的建议下)决定用在 FORTRAN 里实现一门表处理语言,
因为这看来是最简单能开始的方案, 并且当时为新语言写编译器要很多人/年
这些工作被 IBM 的 Herbert Gelernter 和 Carl Gerberich 开展了,
并且成就了 FLPL, 表示 FORTRAN 表处理语言
Gelernter 和 Gerberich 意识到 `cons` 应该是函数而不是子例程,
而且值应该是从自由存储列表取的字的位置
这让新的表达式能通过`cons` 子子表达式多次复合构造出来

当表达式能被 FLPL 轻易处理, 也能被用来在几何程序,
她既没有条件表达式也没有递归, 而且擦除列表被程序显示处理

我发明条件表达式关系到我 1957-58 年在 M.I.T.
为 IBM 704 用 FORTRAN 写的一类法律棋程序
这个程序没用使用表处理程序
在 FORTRAN 1 和 FORTRAN 2 里提供的 IF 语句难看难用,
而且自然可以发明函数 `XIF(X,N1,N2)` 返回值用 `N1` 或 `N2`,
根据表达式 `M` 的值是否为 0
这个函数缩短了很多程序, 使其易于理解, 但他该更少被使用,
因为在 XIF 之前所有 3 个参数都会被求值,
因为 XIF 是用机器语言写的传统的 FORTRAN 函数而被调用的
这导向了 true 表达式的发明, 只有 `N1` 或 `N2` 被执行,
一句 `M` 是 true 或者 false, 并满足一门编程语言需求的渴望(?)

一份定义条件表达式并提议在 Algol 中使用的论文被提交到了,
Communications of the ACM, 但因为太短被编辑随意降级为一封信

应 Nathaniel Rochester 邀请, 我的 1958 年夏天花在了 IBM 信息研究部,
并选了鉴别代数表达式作为一个示例问题
这导向了接下来超越了 FLPL 的创新:

a. 用条件表达式写递归函数定义
这个想法的区别显然在于递归, 条件表达式允许这些组成单个公式

b. `maplist` 函数, 将函数参数应用的列表组成元素的列表
这对任意多项的微分和来说明显是需要的, 轻微修改还可以应用到微分的积
(当时的形式就是现在叫做 `mapcar` 的)

c. 为了将函数用做参数, 就需要函数的记号, 看来自然要用 Church (1941) 的记号
我不懂他树立其他的部分, 所以不打算实现他的更普适的函数定义机制
Church 使用了高阶函数而不是条件表达式
条件表达式是计算机上轻松很多能实现的

d. 分化的递归定义导致废弃的表结构没有现成的删除方法
当是没有解决方案, 但用显式的擦除把优雅的分化定义复杂化的想法没意思
不必说, 事情的重点不是分化程序本身, 他已经被写出来了,
而是符号计算所涉及到的操作的澄清

实际上, 分化程序那个夏天没有实现,
因为 FLPL 既不允许条件表达式, 也不允许子例程的递归调用
这就需要一门新的语言, 因为技术上和政治上都很难摆弄 Fortran,
而且条件表达式和递归都不能在机器语言的 Fortran 函数上实现,
甚至对于函数, 修改调用他们的代码都不行
此外, IBM 群体看起来满足于 FLPL 的样子,
并不想进行需要条件表达式和递归才能进行的说起来模糊的巨大变革
我还能记得, 他们说这些事不必要的
